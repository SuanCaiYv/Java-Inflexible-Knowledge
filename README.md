## 写在最前
现在大三，双非二本，就业压力，内卷左移，我是废物...好久之前，我的朋友们建议我做一个八股文整合，我拒绝了，因为太多了！

于是我们找了一堆八股文提纲，但是每个提纲只是提纲，细致的来说还需要一篇篇介绍，于是有了这个。本文不是八股文背诵讲义，仅仅是我看到的，一些八股文可能会考的，但是讲解比较深入的文章的合计，出处即链接🔗。

本文持续更新...可以收藏或点赞以获取更新状态。
## GitHub上的八股文
 * ⚽️[JavaGuide](https://github.com/Snailclimb/JavaGuide)
 * 🏀[Java3y](https://github.com/ZhongFuCheng3y/3y)
 * 🏐[阿秀的校招笔记](https://github.com/forthespada/InterviewGuide)

## 操作系统
### 进程/线程
进程是最基本的执行体，它拥有一个执行单元最基本的特征，包括PC，寄存器，堆栈，打开文件集，PID等。一个进程可以fork出子进程，在Linux中，子进程和父进程**共享只读空间**。写时复制技术用于子进程想写数据时。

每个进程有一个主线程，线程作为进程执行的实体，一个进程可以拥有多个线程，归属于同一个进程的线程共享全部进程资源。对于内核而言，调度线程取决于线程的类型。

首先，线程分为两种：**用户线程**和**内核线程**。内核线程由内核进程创建，内核本质是一个进程，它所创建的所有线程都叫内核线程；用户线程由非内核进程创建。对于内核线程，调度单位是线程，对于用户线程，调度单位是它所属的进程，所以同一进程内的用户线程需要自行安排调度规则，如果某个用户进程阻塞，则会阻塞整个进程。

为了把用户线程调度的负担丢给内核，出现了LWP轻量级进程，它只有一个主线程，每次创建线程不是在它内部创建线程，二是创建一个新的LWP。前面说过用户线程调度单位是进程，如果一个线程对应一个进程，那就可以实现每个线程由内核调度了，所以LWP就做到了这件事，同时它的组成相对于普通进程更加轻量级。

Linux和Windows都实现了这种策略，即每个线程对应一个进程，让内核调度线程，这样即不用通过创建内核线程这种高昂的方式实现内核调度，也实现了内核对用户线程的调度。

 * 🪂[普通线程和内核线程](https://www.cnblogs.com/alantu2018/p/8526916.html)
### 内存管理

### 文件系统
### I/O
### 同步和锁
这里只说死锁问题。

死锁产生的四个条件
 * 🤺互斥条件：一个资源要么被占有且不可用，要么可用(有些资源可以同时被多个线程占有，这就不能构成死锁)。
 * ⚾️占有与等待：一个拥有了资源的进程可以继续申请其他资源。
 * 🏓不可抢占：其他进程无法强制抢夺某个进程已经获取的资源。
 * 🏸环路等待：发生死锁的系统，必然存在两个或以上的进程互相等待对象资源的释放。

当程序已经开始运行了，检测死锁常用的是**有向环路检测**，通过A->B来表明A等待B的资源释放，多个进程组成一个有向图，如果出现环，说明出现死锁。

当程序还未开始运行呢，检测死锁常用的就是**银行家算法**，通过判断系统是否处于**安全状态**来允许多个进程执行与否。所谓的安全状态指的是，系统从执行第一个线程开始，到所有线程执行结束，都不会发生死锁，那么就成执行前的系统状态未安全状态。

单个资源的银行家算法比较简单，我们直接看多个资源的：

假设有M个进程，N个资源，每种资源的个数为：Res\[N](一维数组)，每个进程需要的每个资源数为Req[M]\[N](二维数组)；每个进程已经获得的每个资源数为：Have[M]\[N]，还需要的资源为：Need[M]\[N]。

 * 1️⃣找到一个线程i，使它第j个资源得到满足，即Need[i][j] <= Res[j]-(Have[0][j] + ... + Have[M-1][j])；即所需资源数<=这种资源剩余数。
 * 2️⃣j = j+1
 * 3️⃣重复1️⃣
 * 4️⃣如果i不满足，i = i+1，重复1️⃣
 * 5️⃣如果j == N，释放i占有的全部资源，继续1️⃣。

其他比如两阶段锁和通信锁，活锁解决均比较简单。
### 处理器架构(偏底层)
### 程序优化(偏底层)
## Java
 * 🐶[Java 面试知识点【背诵版 240题 约7w字】](https://www.nowcoder.com/discuss/447742)
 * 🐱[JVM-锁、JMM、并发](https://juejin.cn/post/6959210088716320799)
 * 🦆[JVM-GC全家桶](https://juejin.cn/post/6937633527009640455)
 * 🐍[Java锁事](https://juejin.cn/post/6975771697588731918)
## MySQL
MySQL中的redolog主要通过记录修改前的数据来实现回滚操作，undolog只要用于持久化修改，因为数据修改需要先把数据加载到buffer中再修改，然后写回磁盘，undolog是追加写的方式，属于顺序I/O，更快一些。具体操作是：写buffer=>写undolog=>异步刷新磁盘(通过定时刷新等手段)。

MySQL为了防止死锁，除了InnoDB提供的资源申请图死锁检测之外，还有MySQL提供的两阶段锁，本意就是把所有的加锁操作放到一起，加锁阶段只加不释放，之后就是解锁阶段，只释放不加。这样可以有效通过打破占有与等待的死锁产生条件来避免死锁。
 * 🍎[InnoDB存储结构](https://juejin.cn/post/6946059131044233247)
 * 🍐[InnoDB四大索引](https://juejin.cn/post/6947961777594302494)
 * 🍋[InnoDB可能用到的锁](https://juejin.cn/post/6950540680531804196)
 * 🍌[MySQL两阶段锁协议、死锁以及死锁检测](https://blog.csdn.net/weixin_38118016/article/details/90271468)
 * 🍉[Innodb中的事务隔离级别和锁的关系](https://tech.meituan.com/2014/08/20/innodb-lock.html)此文约等于3⃣️+4⃣️
 * 🍇[导致MySQL索引失效的几种常见写法](https://juejin.cn/post/6869270318282080263)
 * 🍓[redolog与undolog](http://81.68.154.171:7271/archives/shuo-shuo-mysql-zhong-de-redologundolog-dou-zai-gan-sha-zhuan-zai-ban)
 * 🥝[MySQL分页查询limit优化](https://segmentfault.com/a/1190000008859706)
## NoSQL
 * 🍒[Redis与MySQL双写一致性如何保证？](https://juejin.cn/post/6964531365643550751)
 * 🍑[硬核！16000 字 Redis 面试知识点总结，建议收藏！](https://cloud.tencent.com/developer/article/1595230)
## Spring
## 分布式
### Kafka
### 其他
 * 🚗[限流算法](https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673)
 * 🚑[布隆过滤器](https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md)
## 集群
### Zookeeper
 * 🚌[Zookeeper简述](https://juejin.cn/post/6961432063266258975/)
 * 🛴[Zookeeper的ZAB协议](https://dbaplus.cn/news-141-1875-1.html)
## 网络
### Netty
 * 🚅[设计一个百万级的消息推送系统](https://crossoverjie.top/2018/09/25/netty/million-sms-push/)
### I/O
 * ✈️[谈一谈Java的网络编程](https://juejin.cn/post/6972810594772582431)
## 设计模式
